

// IMPORTANTE:: Led infrarrojo conectado a pin 3
/* Definicion de PINES de los diferentes componentes. No cambiar si no se está seguro de las modificaciones */
#include <IRremote.h>

#define RECV_PIN  2   //Pin donde se reciben datos del sensor IR
#define RCV 4         // Pin conectado al Receptor de la aeronave

#define LED_CALIBRACION 5 // Posibilidad de incluir un led de luz visible para realizar la colimación del laser IR
#define BUZZ 6            //Zumbador

#define LED_R 7       //Leds de status
#define LED_G 8

#define TRIGGER 9     // Gatillo de test manual

#define VER 0.2       // Version actual


IRrecv irrecv(RECV_PIN);
IRsend irsend;

decode_results results;

int salud=100;



void setup()
{

  pinMode(TRIGGER, INPUT_PULLUP);
  pinMode(RCV, INPUT);
  pinMode(LED_CALIBRACION,OUTPUT);
  
  Serial.begin(9600);
  Serial.print("Laser Dog Fight - ver:");
  Serial.print(VER);
  irrecv.enableIRIn(); // Empezamos la recepción  por IR
}


unsigned long dump(decode_results *results) {
  
  // Call this after IRrecv::decode()
  
  Serial.print("(");
  Serial.print(results->bits, DEC);
  Serial.print(" bits)");
  
  if (results->decode_type == UNKNOWN) {
    Serial.print("Unknown encoding: ");
  }
  else if (results->decode_type == NEC) {
    if (results->value != REPEAT){
    Serial.print("Datos recibidos: ");
    Serial.println(results->value);
    return results->value;
    }
  }

  Serial.print(results->value, HEX);
  Serial.print(" (HEX) , ");
  Serial.print(results->value, BIN);
  Serial.println(" (BIN)");

  return -1;
}

void tocado(){                        // Función de daños en la aeronave
  salud -=random(1, 20);              // Se realiza un daño aleatorio de entre 1 y 20 uds.
  if(salud <=0)               
    derribado();
}


void derribado()                      //Funcion a ejecutar cuando eres derribado
{
  int timer=millis();
  timer +=4000
  
  Serial.println("Derribado");        //Se emiten flashes y pitidos durante 4 segundos
  while(timer-millis()>0){
    digitalWrite(LEDS,HIGH);
    digitalWrite(BUZZ,HIGH);
    delay(150);
    digitalWrite(LEDS,LOW);
    digitalWrite(BUZZ,LOW);
    delay(150);

  }
  
  while(1){                          //Despues de 4 segundos cesa el pitido y se deja sólo luz intermitente
   digitalWrite(LEDS,HIGH);
   delay(400);
   digitalWrite(LEDS,LOW);
   delay(400);
  }
  
}

void disparo(){                     // Función a ejecutar cuando se dispara
  
}

void statusFlash(){                 // Flash de estado de salud de la aeronave.
  
}

void calibracion(){
  analogWrite(LED_CALIBRACION,180);
  delay(200);
  while(digitalRead(TRIGGER))
  {
    irsend.sendNEC(1, 32);
    delay(50);
  }
  digitalWrite(LED_CALIBRACION,LOW);
  delay(200);
}

void loop() {
  unsigned long data;
  int ch_trg;
  
  data=0;
  
  if (irrecv.decode(&results)) {
    data=dump(&results); 
    irrecv.resume(); // empezamos una nueva recepción
  }
  /*if(results->value==)
  {
    }
  */
  if(data==1){
    Serial.println("HIT");   //debug
    tocado();
  }
  
  if(pulseIn(RCV, HIGH, 25000) > 10000)
  {
    Serial.println("Disparo");
    disparo();
    irsend.sendNEC(1, 32);
  } 
  if(!digitalRead(TRIGGER)){
    Serial.println("Modo calibracion");
    calibracion();
  }

  statusFlash();
  delay(50);
}
